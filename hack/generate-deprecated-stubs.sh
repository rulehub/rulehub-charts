#!/usr/bin/env bash
set -euo pipefail
# generate-deprecated-stubs.sh
# Detect policy keys in values.yaml marked with deprecated_since: <version>
# and create minimal stub YAML files if the original policy YAML was removed.
# Stubs are created only if the target file does NOT already exist.
# Heuristics:
#   - Keys ending with -policy => Kyverno (ClusterPolicy) in files/kyverno/<key>.yaml
#   - Keys ending with -constraint => Gatekeeper constraint in files/gatekeeper/<key>.yaml
# Other keys (future types) are skipped with a notice.
# The stub intentionally has an empty spec/rules and must remain disabled in values.yaml
# during the deprecation window. Enabling a stub is unsupported and may fail validation.
#
# Usage: ./hack/generate-deprecated-stubs.sh [--values values.yaml]
# Env: VALUES (alternative to --values)
#
# Requirements: bash, standard coreutils (no yq dependency).

VALUES_FILE="values.yaml"
while [[ $# -gt 0 ]]; do
  case "$1" in
    --values)
      VALUES_FILE="$2"; shift 2;;
    *) echo "Unknown argument: $1" >&2; exit 2;;
  esac
done
if [[ -n "${VALUES:-}" ]]; then
  VALUES_FILE="$VALUES"
fi

if [[ ! -f "$VALUES_FILE" ]]; then
  echo "Values file not found: $VALUES_FILE" >&2
  exit 1
fi

echo "[deprecation-stubs] Scanning $VALUES_FILE for deprecated_since markers..." >&2
# Collect line numbers containing deprecated_since
mapfile -t LINES < <(grep -n 'deprecated_since:' "$VALUES_FILE" || true)
if [[ ${#LINES[@]} -eq 0 ]]; then
  echo "[deprecation-stubs] No deprecated_since entries found (nothing to do)." >&2
  exit 0
fi

declare -A KEY_VERSION
for entry in "${LINES[@]}"; do
  lnnum=${entry%%:*}
  version=$(echo "${entry#*:}" | sed -E 's/.*deprecated_since:[[:space:]]*"?([0-9]+\.[0-9]+\.[0-9]+)"?.*/\1/')
  # Walk backwards to find the policy key line (4 space indent + token ending with :)
  keyLine=$(sed -n "1,${lnnum}p" "$VALUES_FILE" | tac | grep -m1 -E '^ {4}[A-Za-z0-9_.-]+:') || true
  if [[ -z "$keyLine" ]]; then
    echo "[WARN] Could not resolve key for deprecated_since at line $lnnum" >&2
    continue
  fi
  key=$(echo "$keyLine" | sed -E 's/^ {4}([^:]+):.*/\1/')
  KEY_VERSION["$key"]="$version"

done

if [[ ${#KEY_VERSION[@]} -eq 0 ]]; then
  echo "[deprecation-stubs] No keys resolved (parser heuristic failed)." >&2
  exit 1
fi

echo "[deprecation-stubs] Deprecated keys detected: ${!KEY_VERSION[*]}" >&2

created=0
skipped=0
for key in "${!KEY_VERSION[@]}"; do
  ver=${KEY_VERSION[$key]}
  if [[ "$key" == *-policy ]]; then
    dir="files/kyverno"
    path="$dir/$key.yaml"
    kind="kyverno"
  elif [[ "$key" == *-constraint ]]; then
    dir="files/gatekeeper"
    path="$dir/$key.yaml"
    kind="gatekeeper"
  else
    echo "[INFO] Skip unsupported key type: $key" >&2
    continue
  fi
  mkdir -p "$dir"
  if [[ -f "$path" ]]; then
    echo "[skip] $path exists" >&2
    ((skipped++))
    continue
  fi
  name=$(echo "$key" | sed 's/_/-/g')
  cat > "$path" <<EOF
# NOTE: autogenerated deprecated stub for policy key $key (deprecated_since: $ver)
# This stub preserves the key during the deprecation window.
# Do NOT enable this stub; it has no operational effect.
EOF
  if [[ "$kind" == "kyverno" ]]; then
    cat >> "$path" <<'EOF'
apiVersion: kyverno.io/v1
kind: ClusterPolicy
metadata:
  name: REPLACED_NAME
  annotations:
    rulehub.deprecated: "true"
    # rulehub.deprecatedSince: VERSION_PLACEHOLDER
spec:
  # Intentionally empty rules list (stub)
  rules: []
EOF
    # Replace placeholders safely
    sed -i "s/REPLACED_NAME/$name/" "$path"
    sed -i "s/VERSION_PLACEHOLDER/$ver/" "$path"
  else
    cat >> "$path" <<'EOF'
apiVersion: constraints.gatekeeper.sh/v1beta1
kind: DeprecatedStubConstraint
metadata:
  name: REPLACED_NAME
  annotations:
    rulehub.deprecated: "true"
    # rulehub.deprecatedSince: VERSION_PLACEHOLDER
spec: {}
EOF
    sed -i "s/REPLACED_NAME/$name/" "$path"
    sed -i "s/VERSION_PLACEHOLDER/$ver/" "$path"
  fi
  echo "[create] $path" >&2
  ((created++))

done

echo "[summary] created=$created skipped=$skipped" >&2
exit 0
