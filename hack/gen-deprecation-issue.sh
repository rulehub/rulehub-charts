#!/usr/bin/env bash
set -euo pipefail

# gen-deprecation-issue.sh
# Auto-generate a GitHub Issue body announcing deprecation of legacy policy keys.
#
# Features:
#  - Computes replacement dash variant (underscore -> dash) when not supplied.
#  - Looks up existing entries in values.yaml to see if replacement already present.
#  - Calculates planned removal version based on a deprecation window (minor increments, default 2).
#  - Emits Markdown with: title suggestion, context, table, checklist.
#
# Usage examples:
#   ./hack/gen-deprecation-issue.sh --keys betting-affordability_checks_uk-policy,betting-source_of_funds_checks-policy
#   ./hack/gen-deprecation-issue.sh --file keys.txt --since 0.2.0 --window 2
#
# Arguments:
#   --keys   Comma separated list of legacy (underscore) keys
#   --file   File containing one key per line (alternative to --keys)
#   --since  Version at which deprecation becomes effective (default: current Chart.yaml version)
#   --window Number of minor releases before removal (default: 2)
#   --values Path to values.yaml (default: values.yaml at repo root)
#   --title  Custom issue title override
#   --no-header  Do not print "###" section headers (for embedding)
#
# Output: Markdown to stdout. Redirect or pipe to gh issue create:
#   ./hack/gen-deprecation-issue.sh --keys k1,k2 | gh issue create --title "Deprecate ..." --body -
#

SCRIPT_DIR="$(cd -- "$(dirname -- "${BASH_SOURCE[0]}")" &>/dev/null && pwd)"
REPO_ROOT="${SCRIPT_DIR%/hack}"

KEYS_RAW=""
KEY_FILE=""
DEPRECATE_SINCE=""
WINDOW=2
VALUES_FILE="$REPO_ROOT/values.yaml"
CUSTOM_TITLE=""
NO_HEADER=0

fail() { echo "[gen-deprecation-issue] ERROR: $*" >&2; exit 1; }
info() { echo "[gen-deprecation-issue] $*" >&2; }

parse_args() {
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --keys) KEYS_RAW="$2"; shift 2;;
      --file) KEY_FILE="$2"; shift 2;;
      --since) DEPRECATE_SINCE="$2"; shift 2;;
      --window) WINDOW="$2"; shift 2;;
      --values) VALUES_FILE="$2"; shift 2;;
      --title) CUSTOM_TITLE="$2"; shift 2;;
      --no-header) NO_HEADER=1; shift;;
      -h|--help)
        grep '^# ' "$0" | sed 's/^# \{0,1\}//'; exit 0;;
      *) fail "Unknown arg: $1";;
    esac
  done
}

chart_version() {
  awk '/^version:/ {print $2; exit}' "$REPO_ROOT/Chart.yaml"
}

increment_minor() { # <semver> <delta>
  local ver="$1"; local delta="$2"
  local major minor patch
  IFS='.' read -r major minor patch <<<"$ver"
  [[ -z $major || -z $minor ]] && fail "Bad semver: $ver"
  local new_minor=$((minor+delta))
  echo "${major}.${new_minor}.0"
}

collect_keys() {
  local list=""
  if [[ -n $KEYS_RAW ]]; then
    IFS=',' read -r -a arr <<<"$KEYS_RAW"
    for k in "${arr[@]}"; do [[ -n $k ]] && list+="$k\n"; done
  fi
  if [[ -n $KEY_FILE ]]; then
    while IFS= read -r line; do [[ -n $line ]] && list+="$line\n"; done < "$KEY_FILE"
  fi
  if [[ -z $list ]]; then
    fail "No keys provided (use --keys or --file)"
  fi
  printf "%b" "$list" | sed '/^$/d' | sort -u
}

dash_variant() { # transform underscores to dashes (only within name, preserve suffix)
  echo "$1" | sed 's/_/-/g'
}

lookup_enabled() { # key
  grep -E "^[[:space:]]+$1:" -n "$VALUES_FILE" >/dev/null 2>&1 && echo yes || echo no
}

replacement_present() { # replacement key
  grep -E "^[[:space:]]+${1}:" "$VALUES_FILE" >/dev/null 2>&1 && echo yes || echo no
}

main() {
  parse_args "$@"
  [[ -f $VALUES_FILE ]] || fail "values file not found: $VALUES_FILE"
  local since_ver="${DEPRECATE_SINCE:-$(chart_version)}"
  local removal_ver
  removal_ver=$(increment_minor "$since_ver" "$WINDOW")
  local keys; keys=$(collect_keys)
  local title
  if [[ -n $CUSTOM_TITLE ]]; then
    title="$CUSTOM_TITLE"
  else
    title="Deprecate legacy policy keys: $(echo "$keys" | tr '\n' ' ' | sed 's/ $//')"
  fi

  local header_prefix="###"
  [[ $NO_HEADER -eq 1 ]] && header_prefix="##" # still keep some formatting consistency

  cat <<MD
<!-- Generated by hack/gen-deprecation-issue.sh at $(date -u +"%Y-%m-%dT%H:%M:%SZ") -->
${header_prefix} Summary
Deprecation proposal for legacy (underscore) policy keys. Window: ${WINDOW} minor release(s).

${header_prefix} Details
Deprecated since: ${since_ver}
Planned removal (no earlier than): ${removal_ver}

${header_prefix} Affected Keys

| legacy_key | enabled_in_values | replacement_key | replacement_present | deprecated_since | removal_version | rationale |
|------------|------------------|-----------------|---------------------|------------------|-----------------|-----------|
MD
  while IFS= read -r k; do
    local repl; repl=$(dash_variant "$k")
    local enabled; enabled=$(lookup_enabled "$k")
    local repl_present; repl_present=$(replacement_present "$repl")
    # Heuristic: if legacy already contains no underscore, mark replacement N/A
    if [[ "$k" == *"_"* ]]; then :; else repl="N/A"; repl_present="n/a"; fi
    printf '| %s | %s | %s | %s | %s | %s | %s |\n' "$k" "$enabled" "$repl" "$repl_present" "$since_ver" "$removal_ver" "TODO: rationale"
  done <<< "$keys"

  cat <<'MD'

### Checklist
- [ ] Add deprecated_since field to each legacy key in values.yaml
- [ ] Add replaced_by field pointing to dash variant (if exists / to be added)
- [ ] Ensure dash variant key (if new) added disabled=false state mirroring original enabled value
- [ ] Update MIGRATION.md mapping table (source -> target)
- [ ] Update README Upgrade Notes / Legacy Keys section
- [ ] Add / Update deprecated stub YAML if policy file renamed (maintain old key as stub)
- [ ] Regenerate VALUES_TABLE.md (make values-table)
- [ ] Run make verify (labels, integrity, deterministic)
- [ ] Open follow-up removal issue targeting version after window (${removal_ver})

### Notes
Removal MUST NOT occur before the declared removal_version even if window passes earlier due to patch releases.
If a replacement dash key does not yet exist, create it in the same release as marking legacy key deprecated.

---
Generated by: hack/gen-deprecation-issue.sh
MD
}

main "$@"
