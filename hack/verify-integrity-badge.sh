#!/usr/bin/env bash
set -euo pipefail
# verify-integrity-badge.sh
# Ensures README integrity badge (first 8 chars) matches current aggregate-integrity hash (excluding placeholders)
# Steps:
# 1. Run aggregate-integrity script (already generated by integrity-all target) to get hash
# 2. Extract expected short hash from README badge pattern: ![integrity](...integrity-<short>-...
# 3. Compare; warn (exit 1) if mismatch so CI can fail prompting update.
# 4. If README missing badge, emit guidance.
# Use: bash hack/verify-integrity-badge.sh
SCRIPT_DIR="$(cd -- "$(dirname -- "${BASH_SOURCE[0]}")" &>/dev/null && pwd)"
ROOT="${SCRIPT_DIR%/hack}"
AGG_LINE=$(bash "$SCRIPT_DIR/aggregate-integrity.sh" | head -1 || true)
if [[ -z "$AGG_LINE" ]]; then
  echo "[integrity-badge] Unable to compute aggregate hash" >&2
  exit 2
fi
AGG_HASH=$(echo "$AGG_LINE" | awk '{print $2}')
SHORT=${AGG_HASH:0:8}
README="$ROOT/README.md"
if [[ ! -f "$README" ]]; then
  echo "[integrity-badge] README.md not found" >&2
  exit 2
fi
BADGE_LINE=$(grep -E '!*\[integrity\]\(https://img.shields.io/badge/integrity-' "$README" || true)
if [[ -z "$BADGE_LINE" ]]; then
  echo "[integrity-badge] Integrity badge not present in README (expected pattern integrity-<hash8>-)." >&2
  exit 1
fi
# Extract between 'integrity-' and next '-'
EXPECTED=$(echo "$BADGE_LINE" | sed -E 's@.*integrity-([0-9a-fA-F]{8})-.*@\1@')
if [[ ! "$EXPECTED" =~ ^[0-9a-fA-F]{8}$ ]]; then
  echo "[integrity-badge] Could not parse expected short hash from badge line." >&2
  echo "$BADGE_LINE" >&2
  exit 1
fi
if [[ "$EXPECTED" != "$SHORT" ]]; then
  echo "[integrity-badge] MISMATCH: README badge=$EXPECTED current=$SHORT" >&2
  echo "Update README badge line (integrity-$SHORT-) after verifying intent." >&2
  exit 1
fi
echo "[integrity-badge] OK: README badge ($EXPECTED) matches aggregate hash prefix ($SHORT)"
